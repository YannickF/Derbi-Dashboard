#include <Arduino.h>
#include <SPI.h>
#include <U8g2lib.h>
#include <avr/interrupt.h>
#include <OneWire.h>

#define MAX_TEMP 30 // temperature maximum pour le capteur 1W -> allumera le voyant si valeur dépassée
#define BATT_MAX 15.0  //tension maxi de la batterie
#define BATT_MIN 10.5  //tension mini de la batterie
#define ALLUME_ESSENCE_VIDE 550 // niveau du convertisseur Analogique numerique qui permet de basculer le voyant d'essence sur ON ou OFF
#define ALLUME_ESSENCE_PLEIN 750 // niveau d'essence PLEIN

#define pin_tension 7
#define pin_phare    A3
#define pin_cligno   A4
#define pin_essence  0
#define pin_huile    A1
#define pin_eau      A2
#define led_rouge    5
#define led_bleue    6
#define led_verte    7
#define BROCHE_ONEWIRE A5

//#define TEMPERATURE   //presence d'une sonde DS18B20
//#define DEBUG

//Pour l'huile, la température d'eau et le carburant, il y a de temps en temps des allumage intempestifs
// si le nombre de micro-allumages des voyants (consécutifs) atteint cette valeur, alors le voyant sera allumée pour de bon
#define COMPT_VOYANT_huile_MAX 20
#define COMPT_VOYANT_eau_MAX 20
#define COMPT_VOYANT_essence_MAX 20
#define COMPT_VOYANT_batt_MAX 20
unsigned char COMPT_VOYANT_huile=0;
unsigned char COMPT_VOYANT_eau=0;
unsigned char COMPT_VOYANT_essence=0;
unsigned char COMPT_VOYANT_batt=0;


/* Code de retour de la fonction getTemperature() */
enum DS18B20_RCODES {
  READ_OK,  // Lecture ok
  NO_SENSOR_FOUND,  // Pas de capteur
  INVALID_ADDRESS,  // Adresse reçue invalide
  INVALID_SENSOR  // Capteur invalide (pas un DS18B20)
};
/* Création de l'objet OneWire pour manipuler le bus 1-Wire */
OneWire ds(BROCHE_ONEWIRE);


unsigned int temp=0;
float tension=0;
float temperature=0;
float essence_f=0; // valeur pour mesurer le "niveau" d'essence (le capteur associé à l'ampoule donne une tension en fonction du niveau, il faut donc utiliser le convertisseur analogique/numerique
signed int temperature_int=0;
boolean phare = false;
boolean cligno = false;
boolean essence = false;
boolean essence_pre_alerte = false;
boolean huile= false;
boolean capt_eau=false;
boolean eau = false;
boolean batterie = false;
boolean aff_alertes=false;  // pour faire clignoter les icones

#define huile_width 40
#define huile_height 20
static unsigned char huile_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
   0x00, 0xec, 0x01, 0x00, 0x00, 0x00, 0x86, 0xf7, 0x07, 0x00, 0x02, 0x06,
   0xc6, 0x00, 0x80, 0x0f, 0x3c, 0xfe, 0x1f, 0xe0, 0x0f, 0xe0, 0xfe, 0x3f,
   0xf8, 0x01, 0x80, 0xff, 0x7f, 0xde, 0x10, 0x00, 0x06, 0xe0, 0x67, 0x10,
   0x00, 0x06, 0xc0, 0x31, 0x38, 0x00, 0x06, 0x80, 0x18, 0x38, 0x00, 0x06,
   0x00, 0x0c, 0x38, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0xfe, 0xff, 0x03,
   0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };
#define eau_width 31
#define eau_height 31
static unsigned char eau_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00,
   0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0xff, 0x00,
   0x00, 0xc0, 0xff, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00,
   0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0xff, 0x00, 0x00, 0xc0, 0xff, 0x00,
   0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00,
   0x00, 0xc0, 0xff, 0x00, 0x00, 0xc0, 0xff, 0x00, 0x00, 0xc0, 0x01, 0x00,
   0x00, 0xc0, 0x01, 0x00, 0x08, 0xc0, 0x01, 0x08, 0x3e, 0xe2, 0x23, 0x3e,
   0xff, 0xf3, 0xe7, 0x7f, 0xc3, 0xf3, 0xe7, 0x63, 0x00, 0xe0, 0x03, 0x00,
   0x00, 0xc0, 0x01, 0x00, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x1c, 0x1c, 0x1c,
   0xfc, 0xff, 0xff, 0x1f, 0xe0, 0xe3, 0xe3, 0x03, 0x80, 0x80, 0x80, 0x00,
   0x00, 0x00, 0x00, 0x00 };
#define essence_width 30
#define essence_height 30
static unsigned char essence_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xf7, 0x01,
   0xf0, 0xff, 0xc7, 0x03, 0xf0, 0xff, 0x87, 0x07, 0x30, 0x00, 0x06, 0x07,
   0x30, 0x00, 0x06, 0x0f, 0x30, 0x00, 0x86, 0x0f, 0x30, 0x00, 0x86, 0x0f,
   0x30, 0x00, 0x06, 0x0f, 0x30, 0x00, 0x06, 0x0e, 0x30, 0x00, 0x7e, 0x0e,
   0x70, 0x00, 0x7f, 0x0e, 0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0e,
   0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0e,
   0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0e,
   0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0e, 0xf0, 0xff, 0xe7, 0x0f,
   0xf0, 0xff, 0xc7, 0x07, 0xf8, 0xff, 0x0f, 0x01, 0xfc, 0xff, 0x1f, 0x00,
   0xfc, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define cligno_width 40
#define cligno_height 26
static unsigned char cligno_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x30, 0x00, 0x00, 0x0e, 0x00, 0x70,
   0x00, 0x00, 0x0f, 0x00, 0xf0, 0x00, 0x80, 0xfd, 0xc3, 0xbf, 0x01, 0xc0,
   0xfc, 0xc3, 0x3f, 0x03, 0x60, 0x00, 0x42, 0x00, 0x06, 0x30, 0x00, 0x42,
   0x00, 0x0c, 0x18, 0x00, 0x42, 0x00, 0x18, 0x0c, 0x00, 0x42, 0x00, 0x30,
   0x06, 0x00, 0x42, 0x00, 0x60, 0x06, 0x00, 0x42, 0x00, 0x60, 0x0c, 0x00,
   0x42, 0x00, 0x30, 0x18, 0x00, 0x42, 0x00, 0x18, 0x30, 0x00, 0x42, 0x00,
   0x0c, 0x60, 0x00, 0x42, 0x00, 0x06, 0xc0, 0xfc, 0xc3, 0x3f, 0x03, 0x80,
   0xfd, 0xc3, 0xbf, 0x01, 0x00, 0x0f, 0x00, 0xf0, 0x00, 0x00, 0x0e, 0x00,
   0x70, 0x00, 0x00, 0x0c, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
#define phare_width 40
#define phare_height 29
static unsigned char phare_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
   0xe0, 0x0f, 0x00, 0xfc, 0x3f, 0xf8, 0x7f, 0x00, 0xfc, 0x3f, 0x3c, 0xf8,
   0x01, 0x00, 0x00, 0x1e, 0xe0, 0x03, 0x00, 0x00, 0x06, 0x80, 0x07, 0x00,
   0x00, 0x06, 0x00, 0x0f, 0xfc, 0x3f, 0x07, 0x00, 0x1c, 0xfc, 0x3f, 0x07,
   0x00, 0x1c, 0x00, 0x00, 0x03, 0x00, 0x38, 0x00, 0x00, 0x03, 0x00, 0x30,
   0x00, 0x00, 0x03, 0x00, 0x30, 0xfc, 0x3f, 0x03, 0x00, 0x30, 0xfc, 0x3f,
   0x03, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00,
   0x38, 0x00, 0x00, 0x03, 0x00, 0x18, 0xfc, 0x3f, 0x07, 0x00, 0x1c, 0xfc,
   0x3f, 0x07, 0x00, 0x0e, 0x00, 0x00, 0x06, 0x00, 0x07, 0x00, 0x00, 0x0e,
   0xc0, 0x03, 0x00, 0x00, 0x1c, 0xf8, 0x01, 0xfc, 0x3f, 0xf8, 0x7f, 0x00,
   0xfc, 0x3f, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00 };
#define croisement_width 40
#define croisement_height 29
static unsigned char croisement_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
   0xe0, 0x0f, 0x00, 0x00, 0x38, 0xf8, 0x7f, 0x00, 0x00, 0x3e, 0x3c, 0xf8,
   0x01, 0xc0, 0x0f, 0x1e, 0xe0, 0x03, 0xf0, 0x03, 0x06, 0x80, 0x07, 0x7c,
   0x00, 0x06, 0x00, 0x0f, 0x0e, 0x38, 0x07, 0x00, 0x1c, 0x00, 0x3e, 0x07,
   0x00, 0x1c, 0xc0, 0x0f, 0x03, 0x00, 0x38, 0xf0, 0x03, 0x03, 0x00, 0x30,
   0x7c, 0x00, 0x03, 0x00, 0x30, 0x0e, 0x38, 0x03, 0x00, 0x30, 0x00, 0x3e,
   0x03, 0x00, 0x30, 0xc0, 0x0f, 0x03, 0x00, 0x30, 0xf0, 0x03, 0x03, 0x00,
   0x38, 0x7c, 0x00, 0x03, 0x00, 0x18, 0x0e, 0x38, 0x07, 0x00, 0x1c, 0x00,
   0x3e, 0x07, 0x00, 0x0e, 0xc0, 0x0f, 0x06, 0x00, 0x07, 0xf0, 0x03, 0x0e,
   0xc0, 0x03, 0x7c, 0x00, 0x1c, 0xf8, 0x01, 0x0e, 0x38, 0xf8, 0x7f, 0x00,
   0x00, 0x3e, 0xf0, 0x1f, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0x00, 0xf0, 0x03,
   0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
   0x00 };
#define batterie_width 28
#define batterie_height 21
static unsigned char batterie_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x78, 0x00,
   0xe0, 0x01, 0x78, 0x00, 0xe0, 0x01, 0x78, 0x00, 0xfc, 0xff, 0xff, 0x03,
   0xfc, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0x03,
   0xfc, 0xff, 0xcf, 0x03, 0xfc, 0xff, 0xcf, 0x03, 0x0c, 0xfc, 0x03, 0x03,
   0x0c, 0xfc, 0x03, 0x03, 0xfc, 0xff, 0xcf, 0x03, 0xfc, 0xff, 0xcf, 0x03,
   0xfc, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0x03,
   0xfc, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };





/* Constructor */
U8G2_SH1106_128X64_NONAME_1_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 9, /* dc=*/ 10, /* reset=*/ 12);  //CS non connecté en réalité



/* u8g2.begin() is required and will sent the setup/init sequence to the display */
void setup(void) {
#ifdef DEBUG
  Serial.begin(57600);  // meme débit que le bootloader (old)
#endif
  // configuration des broches en entrées / sorties
  analogReference(DEFAULT);
  pinMode(pin_tension,INPUT);
  pinMode(pin_phare,INPUT);
  pinMode(pin_cligno,INPUT);
  pinMode(pin_essence,INPUT);
  pinMode(pin_huile,INPUT_PULLUP);
  pinMode(pin_eau,INPUT_PULLUP);
  pinMode(led_rouge,OUTPUT);
  pinMode(led_bleue,OUTPUT);
  pinMode(led_verte,OUTPUT);

  // réduction de la résolution du DS18B20
  setResolution9bits();

  // paramétrage de l'écran OLED
  u8g2.begin();
  // animation de boot
  for (int i=0;i<65;i++) {
    u8g2.firstPage();
    do {
      u8g2.drawBox(64-i,0,2*i,64);
    } while ( u8g2.nextPage() );
  }
  for (int i=65;i>=0;i--) {
    u8g2.firstPage();
    do {
      u8g2.drawBox(64-i,0,2*i,64);
    } while ( u8g2.nextPage() );
  }


  // test des LED
  digitalWrite(led_verte,HIGH);
  delay(250);
  digitalWrite(led_rouge,HIGH);
  delay(250);
  digitalWrite(led_bleue,HIGH);
  delay(500);
  digitalWrite(led_bleue,LOW);
  delay(250);
  digitalWrite(led_rouge,LOW);
  delay(250);
  digitalWrite(led_verte,LOW);
}

/* draw something on the display with the `firstPage()`/`nextPage()` loop*/
void loop(void) {
#ifdef TEMPERATURE
   // Lecture de la température via sonde DS18B20
   if (getTemperature(&temperature, true) != READ_OK) {
     temperature=-99;
      return;
   }
#else
  temperature=99;
#endif

   //  lecture de la tension, on fait la moyenne sur 16 lectures
   temp=0;
   for (char i=0;i<=15;i++) {
    temp+=analogRead(pin_tension);
   }
   tension=(float) (temp / 16)  ;
   tension = tension* 0.015272;  // c'est le coefficient du convertisseur ADC

  //  lecture du niveau d'essence, on fait la moyenne sur 16 lectures (on pourrait le faire en même temps que pour la tension)
   temp=0;
   for (char i=0;i<=15;i++) {
    temp+=analogRead(pin_essence); 
   }
   essence_f=(float) (temp / 16)  ;
   if (essence_f <= ALLUME_ESSENCE_VIDE) {essence=true; essence_pre_alerte=false;}
   else if (essence_f >= ALLUME_ESSENCE_PLEIN) {essence=false; essence_pre_alerte=false;}
   else {essence=false; essence_pre_alerte=true;}
   
 #ifdef DEBUG
  Serial.print("Essence : ");
  Serial.println(essence_f);
  Serial.print("Alerte : ");
  Serial.println(essence);
  Serial.print("Pre-Alerte : ");
  Serial.println(essence_pre_alerte);
  Serial.println();
 #endif
  // lecture des états des broches
  phare=digitalRead(pin_phare);
  cligno=digitalRead(pin_cligno);
  //essence=!digitalRead(pin_essence);
  huile=!digitalRead(pin_huile);
  capt_eau=!digitalRead(pin_eau);

  // TEST pour éviter les déclenchement intempestifs des alertes
  if (essence) {
    COMPT_VOYANT_essence++;
    if (COMPT_VOYANT_essence < COMPT_VOYANT_essence_MAX) {essence=false;}
  }
  else {
    COMPT_VOYANT_essence=0;
  }
  if (huile) {
    COMPT_VOYANT_huile++;
    if (COMPT_VOYANT_huile < COMPT_VOYANT_huile_MAX) {huile=false;}
  }
  else {
    COMPT_VOYANT_huile=0;
  }
  if (capt_eau) {
    COMPT_VOYANT_eau++;
    if (COMPT_VOYANT_eau < COMPT_VOYANT_eau_MAX) {capt_eau=false;}
  }
  else {
    COMPT_VOYANT_eau=0;
  }
  if ((tension > BATT_MAX) or (tension < BATT_MIN)) {
    COMPT_VOYANT_batt++;
    batterie=true;
    if (COMPT_VOYANT_batt < COMPT_VOYANT_batt_MAX) {batterie=false;}
  }
  else {
    COMPT_VOYANT_batt=0;
    batterie=false;
  }

  // TEST POUR DECLENCHER LES ALERTES sur les LED
  if (phare) {digitalWrite(led_bleue,HIGH);} else {digitalWrite(led_bleue, LOW);}
  if (cligno) {digitalWrite(led_verte,HIGH);} else {digitalWrite(led_verte, LOW);}
  if (essence or huile or eau  or batterie) {digitalWrite(led_rouge,HIGH);} else {digitalWrite(led_rouge, LOW);} 
  // on n'allume pas la LED rouge en cas de pré-alerte essence
  if (capt_eau or (temperature_int >= MAX_TEMP)) {eau=true;} else {eau=false;}


  // AFFICHAGE SUR L'ECRAN
  u8g2.firstPage();
  do {
    // quadrillage
    u8g2.drawHLine(0,32,128);
    u8g2.drawVLine(42,0,64);
    u8g2.drawVLine(85,0,64);

    // affichage de la tension et de la température (sauf si voyant de batterie)
    if (batterie and aff_alertes)
    {
      u8g2.drawXBM( 50, 5, batterie_width, batterie_height, batterie_bits);
    }
    else
    {
      u8g2.setFont(u8g2_font_courB08_tf);
      u8g2.drawStr(77, 11, "V");
#ifdef TEMPERATURE
      u8g2.drawUTF8(72,26,"°C");
#endif
      u8g2.setCursor(47,11);
      u8g2.print(tension,1);
      u8g2.setCursor(55,26);
#ifdef TEMPERATURE
      temperature_int=(int) int(temperature);  // on ne garde que la partie entière de la température
      u8g2.print(temperature_int);
#endif
    }

    // affichage huile
    if (huile and aff_alertes) {u8g2.drawXBM( 44, 38, huile_width, huile_height, huile_bits);}
    // affichage eau
    if (eau and aff_alertes) {u8g2.drawXBM( 92, 33, eau_width, eau_height, eau_bits);}
    // affichage pre alerte essence (sans clignoter)
    if (essence_pre_alerte) {u8g2.drawXBM( 5, 33, essence_width, essence_height, essence_bits);}
    // affichage essence
    if (essence and aff_alertes) {u8g2.drawXBM( 5, 33, essence_width, essence_height, essence_bits);}
    //affichage cligno
    if (cligno==true) {u8g2.drawXBM( 88, 3, cligno_width, cligno_height, cligno_bits);}
    //affichage phare/croisement
    if (phare==true) {u8g2.drawXBM( 1, 1, phare_width, phare_height, phare_bits);}
    else {u8g2.drawXBM( 1, 1, croisement_width, croisement_height, croisement_bits);}
  } while ( u8g2.nextPage() );

  // on fait clignoter les voyants
  aff_alertes=!aff_alertes;
  delay(100);





}


void setResolution9bits(void) {
  byte addr[8];
  // data[] : Données lues depuis le scratchpad
  // addr[] : Adresse du module 1-Wire détecté
  ds.search(addr);
  if (addr[0] == 0x28)   // on verifie que c'est un DS18B20
  {
    Serial.print("C'est bien un DS18B20");
    // Réduction de la résolution du capteur à 9 bits
    ds.reset(); // rest 1-Wire
    ds.select(addr); // select DS18B20
    ds.write(0x4E); // write on scratchPad
    ds.write(0x00); // User byte 0 - Unused
    ds.write(0x00); // User byte 1 - Unused
    ds.write(0x1F); // set up en 9 bits (0x1F)
    ds.reset(); // reset 1-Wire
  }
}

/**
 * Fonction de lecture de la température via un capteur DS18B20.
 */
byte getTemperature(float *temperature, byte reset_search) {
  byte data[9], addr[8];
  // data[] : Données lues depuis le scratchpad
  // addr[] : Adresse du module 1-Wire détecté

  /* Reset le bus 1-Wire ci nécessaire (requis pour la lecture du premier capteur) */
  if (reset_search) {
    ds.reset_search();
  }

  /* Recherche le prochain capteur 1-Wire disponible */
  if (!ds.search(addr)) {
    // Pas de capteur
    return NO_SENSOR_FOUND;
  }

  /* Vérifie que l'adresse a été correctement reçue */
  if (OneWire::crc8(addr, 7) != addr[7]) {
    // Adresse invalide
    return INVALID_ADDRESS;
  }

  /* Vérifie qu'il s'agit bien d'un DS18B20 */
  if (addr[0] != 0x28) {
    // Mauvais type de capteur
    return INVALID_SENSOR;
  }




  /* Reset le bus 1-Wire et sélectionne le capteur */
  ds.reset();
  ds.select(addr);

  /* Lance une prise de mesure de température et attend la fin de la mesure
      On attend 100 ms au lieu de 800 puisqu'on a réduit la résolution et que cela réduit le temps de conversion
  */
  ds.write(0x44, 1);
  delay(100);

  /* Reset le bus 1-Wire, sélectionne le capteur et envoie une demande de lecture du scratchpad */
  ds.reset();
  ds.select(addr);
  ds.write(0xBE);

 /* Lecture du scratchpad */
  for (byte i = 0; i < 9; i++) {
    data[i] = ds.read();
  }

  /* Calcul de la température en degré Celsius */
  *temperature = ((data[1] << 8) | data[0]) * 0.0625;

  // Pas d'erreur
  return READ_OK;
}
